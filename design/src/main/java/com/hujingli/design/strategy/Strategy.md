### 策略模式

---

![github](http://154.8.226.45/learnnote/strategy.jpg "github")

如上图所示 以鸭子行为为例

1、鸭子有不同的种类

2、鸭子有不同的行为

3、鸭子有部分公共内容

```java
abstract class Duck{
    swim();
    display();
    quack();
    fly();

    // 如上3中行为可以是相同的也可以是不同的

}
```
如果现在有不同的种类的鸭子  如红头鸭 、 绿头鸭等等  不同种类
的鸭子的行为是不同的，有的会游泳，有的不会，有的gaga叫有的
gugu叫。

传统的做法就是鸭子的具体子类继承Duck超类，各自实现自己的行为。

```java
class RedHeadDuck extends Duck{
    swim(){
        System.out.println("会游泳");
    }
}
```

```java
class GreenHeadDuck extends Duck{
    swim(){
        System.out.println("不会游泳");
    }
}
```

具体的行为是由子类自己进行实现  

如果此时多了一种石头鸭子 它也不会游泳，但是它也需要自己去
实现这个swim方法，代码的复用性就变得很差。石头鸭子和红头鸭子
都不会游泳但也需要进行各自的重复实现。

2、引入策略模式

 - 策略模式属于一种行为型模式。
 
策略模式将行为定义为一个算法，具体的实现行成了算法族。

如本例：

1、鸭子飞是一个行为

> 具体的会飞和和不会飞还是其它的怎么飞都是飞这个行为的具体
>实现。一个行为的不同实现聚集在一起便形成了一个算法族


2、鸭子叫是一个行为

>具体的gaga叫或者是gugu叫都是叫这个行为的具体实现。

不同的鸭子针对不同的行为装配对应的具体行为实现。

